{"version":3,"file":"CfmmjSnu.js","sources":["../../../../../../src/lib/api/apiClient.ts","../../../../../../src/lib/stores/authStore.ts"],"sourcesContent":["// API Client for JWT authentication with FastAPI backend\n\nimport { goto } from '$app/navigation';\nimport type { \n  LoginRequest, \n  TokenResponse, \n  AuthenticatedUser, \n  UserSession,\n  RefreshTokenRequest,\n  PasswordChangeRequest,\n  UserRegistrationRequest,\n  UserResponse,\n  APIError as APIErrorType\n} from '$lib/types/auth';\n\n// Custom API Error class\nexport class APIError extends Error implements APIErrorType {\n  constructor(\n    public status: number,\n    public message: string,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'APIError';\n  }\n}\n\n// Main API Client class\nexport class APIClient {\n  private baseURL: string;\n  private accessToken: string | null = null;\n  private refreshToken: string | null = null;\n  private isRefreshing = false;\n  private refreshPromise: Promise<void> | null = null;\n\n  constructor() {\n    // Use environment variable or fallback to localhost for development\n    this.baseURL = this.getBaseURL();\n  }\n\n  private getBaseURL(): string {\n    if (typeof window !== 'undefined') {\n      // In browser - check for environment variable\n      const envBaseURL = import.meta.env.PUBLIC_API_BASE_URL;\n      if (envBaseURL) {\n        return envBaseURL;\n      }\n      \n      // Development fallback\n      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n        return 'http://localhost:8080';\n      }\n      \n      // Production fallback - same domain with different port or subdomain\n      return `${window.location.protocol}//api.${window.location.hostname}`;\n    }\n    \n    // Server-side fallback\n    return 'http://localhost:8080';\n  }\n\n  // Set tokens\n  setTokens(accessToken: string, refreshToken: string) {\n    this.accessToken = accessToken;\n    this.refreshToken = refreshToken;\n  }\n\n  // Clear tokens\n  clearTokens() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    this.isRefreshing = false;\n    this.refreshPromise = null;\n  }\n\n  // Get current access token\n  getAccessToken(): string | null {\n    return this.accessToken;\n  }\n\n  // Generic request method with automatic token refresh\n  async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    // Ensure we have fresh tokens if needed\n    if (this.accessToken && this.isTokenExpiringSoon()) {\n      await this.refreshAccessToken();\n    }\n\n    let response = await this.makeRequest(endpoint, options);\n\n    // If we get 401, try to refresh token and retry once\n    if (response.status === 401 && this.refreshToken && !this.isRefreshing) {\n      try {\n        await this.refreshAccessToken();\n        response = await this.makeRequest(endpoint, options);\n      } catch (refreshError) {\n        // Refresh failed, redirect to login\n        this.handleAuthenticationFailure();\n        throw new APIError(401, 'Session expired. Please log in again.');\n      }\n    }\n\n    return this.handleResponse<T>(response);\n  }\n\n  // Make HTTP request with proper headers\n  private async makeRequest(endpoint: string, options: RequestInit = {}): Promise<Response> {\n    const url = `${this.baseURL}${endpoint}`;\n    \n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      ...options.headers as Record<string, string>,\n    };\n\n    // Add Authorization header if we have a token\n    if (this.accessToken) {\n      headers['Authorization'] = `Bearer ${this.accessToken}`;\n    }\n\n    return fetch(url, {\n      ...options,\n      headers,\n    });\n  }\n\n  // Handle response and errors\n  private async handleResponse<T>(response: Response): Promise<T> {\n    if (!response.ok) {\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n      let errorDetails: any = {};\n\n      try {\n        const errorData = await response.json();\n        errorMessage = errorData.detail || errorData.message || errorMessage;\n        errorDetails = errorData;\n      } catch {\n        // If we can't parse JSON, use the default message\n      }\n\n      throw new APIError(response.status, errorMessage, errorDetails);\n    }\n\n    // Handle empty responses\n    if (response.status === 204 || response.headers.get('content-length') === '0') {\n      return {} as T;\n    }\n\n    try {\n      return await response.json();\n    } catch {\n      throw new APIError(500, 'Invalid JSON response from server');\n    }\n  }\n\n  // Check if token is expiring soon (within 5 minutes)\n  private isTokenExpiringSoon(): boolean {\n    if (!this.accessToken) return false;\n    \n    try {\n      // Decode JWT token to check expiration\n      const payload = JSON.parse(atob(this.accessToken.split('.')[1]));\n      const exp = payload.exp * 1000; // Convert to milliseconds\n      const now = Date.now();\n      const fiveMinutes = 5 * 60 * 1000;\n      \n      return exp - now < fiveMinutes;\n    } catch {\n      // If we can't decode, assume it's expiring\n      return true;\n    }\n  }\n\n  // Refresh access token\n  private async refreshAccessToken(): Promise<void> {\n    if (this.isRefreshing && this.refreshPromise) {\n      await this.refreshPromise;\n      return;\n    }\n\n    if (!this.refreshToken) {\n      throw new APIError(401, 'No refresh token available');\n    }\n\n    this.isRefreshing = true;\n    this.refreshPromise = this.performTokenRefresh();\n    \n    try {\n      await this.refreshPromise;\n    } finally {\n      this.isRefreshing = false;\n      this.refreshPromise = null;\n    }\n  }\n\n  // Perform the actual token refresh\n  private async performTokenRefresh(): Promise<void> {\n    try {\n      const response = await fetch(`${this.baseURL}/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          refresh_token: this.refreshToken,\n        } as RefreshTokenRequest),\n      });\n\n      if (!response.ok) {\n        throw new APIError(response.status, 'Failed to refresh token');\n      }\n\n      const tokenData: TokenResponse = await response.json();\n      this.setTokens(tokenData.access_token, tokenData.refresh_token);\n      \n      // Dispatch event for stores to update\n      if (typeof window !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('token-refreshed', { \n          detail: tokenData \n        }));\n      }\n    } catch (error) {\n      this.clearTokens();\n      throw error;\n    }\n  }\n\n  // Handle authentication failure\n  private handleAuthenticationFailure() {\n    this.clearTokens();\n    \n    // Dispatch event for stores to update\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(new CustomEvent('auth-failed'));\n      \n      // Redirect to login if not already there\n      if (!window.location.pathname.includes('/login')) {\n        goto('/login');\n      }\n    }\n  }\n\n  // =============================================================================\n  // AUTHENTICATION ENDPOINTS\n  // =============================================================================\n\n  async login(credentials: LoginRequest): Promise<TokenResponse> {\n    try {\n      const response = await fetch(`${this.baseURL}/auth/login`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(credentials),\n      });\n\n      if (!response.ok) {\n        let errorMessage = 'Login failed';\n        try {\n          const errorData = await response.json();\n          errorMessage = errorData.detail || errorData.message || errorMessage;\n        } catch {\n          // Use default message if can't parse response\n        }\n        throw new APIError(response.status, errorMessage);\n      }\n\n      const tokenData: TokenResponse = await response.json();\n      this.setTokens(tokenData.access_token, tokenData.refresh_token);\n      \n      return tokenData;\n    } catch (error) {\n      if (error instanceof APIError) {\n        throw error;\n      }\n      throw new APIError(0, 'Network error during login');\n    }\n  }\n\n  async logout(): Promise<void> {\n    try {\n      if (this.accessToken) {\n        await this.request('/auth/logout', {\n          method: 'POST',\n        });\n      }\n    } catch (error) {\n      // Logout errors are not critical, we'll clear tokens anyway\n      console.warn('Logout request failed:', error);\n    } finally {\n      this.clearTokens();\n    }\n  }\n\n  async getCurrentUser(): Promise<AuthenticatedUser> {\n    return this.request<AuthenticatedUser>('/auth/me');\n  }\n\n  async changePassword(request: PasswordChangeRequest): Promise<void> {\n    await this.request('/auth/me/password', {\n      method: 'PUT',\n      body: JSON.stringify(request),\n    });\n  }\n\n  async getUserSessions(): Promise<{ sessions: UserSession[] }> {\n    return this.request<{ sessions: UserSession[] }>('/auth/sessions');\n  }\n\n  async revokeSession(sessionId: string): Promise<void> {\n    await this.request(`/auth/sessions/${sessionId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // Admin endpoints\n  async registerUser(request: UserRegistrationRequest): Promise<UserResponse> {\n    return this.request<UserResponse>('/auth/register', {\n      method: 'POST',\n      body: JSON.stringify(request),\n    });\n  }\n\n  async getUsers(clientId?: string, limit = 50, offset = 0): Promise<UserResponse[]> {\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString(),\n    });\n    \n    if (clientId) {\n      params.append('client_id', clientId);\n    }\n\n    return this.request<UserResponse[]>(`/auth/users?${params}`);\n  }\n\n  async deleteUser(userId: number): Promise<void> {\n    await this.request(`/auth/users/${userId}`, {\n      method: 'DELETE',\n    });\n  }\n\n  // =============================================================================\n  // HEALTH AND STATUS ENDPOINTS\n  // =============================================================================\n\n  async getHealth(): Promise<any> {\n    return this.request('/health');\n  }\n\n  async getDetailedHealth(): Promise<any> {\n    return this.request('/health/detailed');\n  }\n}\n\n// Export singleton instance\nexport const apiClient = new APIClient();\n\n// Utility function for handling API errors in components\nexport function handleAPIError(error: unknown): string {\n  if (error instanceof APIError) {\n    return error.message;\n  }\n  \n  if (error instanceof Error) {\n    return error.message;\n  }\n  \n  return 'An unexpected error occurred';\n} ","// JWT Authentication Store for Email Router\n\nimport { writable, derived, get } from 'svelte/store';\nimport { browser } from '$app/environment';\nimport { goto } from '$app/navigation';\nimport { apiClient, handleAPIError } from '$lib/api/apiClient';\nimport type { \n  AuthState, \n  LoginRequest, \n  AuthenticatedUser, \n  PasswordChangeRequest,\n  UserRegistrationRequest,\n  UserResponse,\n  UserSession \n} from '$lib/types/auth';\n\n// Initial auth state\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n  isLoading: false,\n  error: null,\n  accessToken: null,\n  refreshToken: null,\n};\n\n// Core auth store\nconst authState = writable<AuthState>(initialState);\n\n// Derived stores for easier access\nexport const isAuthenticated = derived(authState, $state => $state.isAuthenticated);\nexport const currentUser = derived(authState, $state => $state.user);\nexport const isLoading = derived(authState, $state => $state.isLoading);\nexport const authError = derived(authState, $state => $state.error);\n\n// Store update helpers\nfunction updateState(updates: Partial<AuthState>) {\n  authState.update(state => ({ ...state, ...updates }));\n}\n\nfunction setLoading(isLoading: boolean) {\n  updateState({ isLoading, error: null });\n}\n\nfunction setError(error: string | null) {\n  updateState({ error, isLoading: false });\n}\n\n// Token storage helpers\nconst TOKEN_STORAGE_KEY = 'email-router-tokens';\n\nfunction saveTokensToStorage(accessToken: string, refreshToken: string) {\n  if (!browser) return;\n  \n  try {\n    localStorage.setItem(TOKEN_STORAGE_KEY, JSON.stringify({\n      accessToken,\n      refreshToken,\n      timestamp: Date.now(),\n    }));\n  } catch (error) {\n    console.warn('Failed to save tokens to localStorage:', error);\n  }\n}\n\nfunction loadTokensFromStorage(): { accessToken: string; refreshToken: string } | null {\n  if (!browser) return null;\n  \n  try {\n    const stored = localStorage.getItem(TOKEN_STORAGE_KEY);\n    if (!stored) return null;\n    \n    const { accessToken, refreshToken, timestamp } = JSON.parse(stored);\n    \n    // Check if tokens are not too old (7 days)\n    const sevenDays = 7 * 24 * 60 * 60 * 1000;\n    if (Date.now() - timestamp > sevenDays) {\n      localStorage.removeItem(TOKEN_STORAGE_KEY);\n      return null;\n    }\n    \n    return { accessToken, refreshToken };\n  } catch (error) {\n    console.warn('Failed to load tokens from localStorage:', error);\n    localStorage.removeItem(TOKEN_STORAGE_KEY);\n    return null;\n  }\n}\n\nfunction clearTokensFromStorage() {\n  if (!browser) return;\n  localStorage.removeItem(TOKEN_STORAGE_KEY);\n}\n\n// Authentication service class\nclass AuthService {\n  // Initialize auth state from storage\n  async initialize() {\n    if (!browser) return;\n\n    setLoading(true);\n\n    try {\n      const storedTokens = loadTokensFromStorage();\n      if (!storedTokens) {\n        setLoading(false);\n        return;\n      }\n\n      // Set tokens in API client\n      apiClient.setTokens(storedTokens.accessToken, storedTokens.refreshToken);\n\n      // Try to get current user to validate tokens\n      const user = await apiClient.getCurrentUser();\n\n      updateState({\n        user,\n        isAuthenticated: true,\n        accessToken: storedTokens.accessToken,\n        refreshToken: storedTokens.refreshToken,\n        isLoading: false,\n        error: null,\n      });\n\n      console.log('‚úÖ Auth initialized successfully');\n\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Auth initialization failed:', error);\n      this.clearAuth();\n    }\n  }\n\n  // Login with username and password\n  async login(credentials: LoginRequest): Promise<{ success: boolean; error?: string }> {\n    setLoading(true);\n\n    try {\n      console.log('üîê Attempting login for user:', credentials.username);\n\n      // Call login API\n      const tokenResponse = await apiClient.login(credentials);\n      console.log('‚úÖ Login successful, received tokens');\n\n      // Get user information\n      const user = await apiClient.getCurrentUser();\n      console.log('‚úÖ User info retrieved:', user.username);\n\n      // Update state\n      updateState({\n        user,\n        isAuthenticated: true,\n        accessToken: tokenResponse.access_token,\n        refreshToken: tokenResponse.refresh_token,\n        isLoading: false,\n        error: null,\n      });\n\n      // Save tokens to storage\n      saveTokensToStorage(tokenResponse.access_token, tokenResponse.refresh_token);\n\n      console.log('üéâ Login completed successfully!');\n      return { success: true };\n\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      console.error('‚ùå Login failed:', errorMessage);\n      \n      setError(errorMessage);\n      this.clearAuth();\n      \n      return { success: false, error: errorMessage };\n    }\n  }\n\n  // Logout\n  async logout(): Promise<void> {\n    setLoading(true);\n\n    try {\n      // Call logout API\n      await apiClient.logout();\n      console.log('‚úÖ Logout API call successful');\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Logout API call failed:', error);\n      // Continue with local logout even if API call fails\n    }\n\n    this.clearAuth();\n    console.log('üîê Logout completed');\n\n    // Redirect to login page\n    goto('/login');\n  }\n\n  // Clear authentication state\n  private clearAuth() {\n    // Clear API client tokens\n    apiClient.clearTokens();\n    \n    // Clear storage\n    clearTokensFromStorage();\n    \n    // Reset state\n    updateState({\n      user: null,\n      isAuthenticated: false,\n      accessToken: null,\n      refreshToken: null,\n      isLoading: false,\n      error: null,\n    });\n  }\n\n  // Change password\n  async changePassword(request: PasswordChangeRequest): Promise<{ success: boolean; error?: string }> {\n    setLoading(true);\n\n    try {\n      await apiClient.changePassword(request);\n      \n      updateState({ isLoading: false, error: null });\n      return { success: true };\n\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      setError(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  // Refresh user info\n  async refreshUserInfo(): Promise<void> {\n    if (!get(isAuthenticated)) return;\n\n    try {\n      const user = await apiClient.getCurrentUser();\n      updateState({ user });\n    } catch (error) {\n      console.warn('Failed to refresh user info:', error);\n      // Don't clear auth for this error, might be temporary\n    }\n  }\n\n  // Get user sessions\n  async getUserSessions(): Promise<{ success: boolean; sessions?: UserSession[]; error?: string }> {\n    try {\n      const response = await apiClient.getUserSessions();\n      return { success: true, sessions: response.sessions };\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  // Revoke session\n  async revokeSession(sessionId: string): Promise<{ success: boolean; error?: string }> {\n    try {\n      await apiClient.revokeSession(sessionId);\n      return { success: true };\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  // Admin functions - User management\n  async registerUser(request: UserRegistrationRequest): Promise<{ success: boolean; user?: UserResponse; error?: string }> {\n    try {\n      const user = await apiClient.registerUser(request);\n      return { success: true, user };\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async getUsers(clientId?: string): Promise<{ success: boolean; users?: UserResponse[]; error?: string }> {\n    try {\n      const users = await apiClient.getUsers(clientId);\n      return { success: true, users };\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async deleteUser(userId: number): Promise<{ success: boolean; error?: string }> {\n    try {\n      await apiClient.deleteUser(userId);\n      return { success: true };\n    } catch (error) {\n      const errorMessage = handleAPIError(error);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  // Check permissions\n  hasPermission(permission: string): boolean {\n    const user = get(currentUser);\n    if (!user) return false;\n\n    // Super admin has all permissions\n    if (user.role === 'super_admin') return true;\n\n    // Role-based permissions\n    switch (user.role) {\n      case 'client_admin':\n        return ['client:read', 'client:write', 'routing:read', 'routing:write', \n                'branding:read', 'branding:write', 'users:read', 'users:write'].includes(permission);\n      case 'client_user':\n        return ['client:read', 'routing:read', 'branding:read'].includes(permission);\n      case 'api_user':\n        return ['client:read'].includes(permission);\n      default:\n        return false;\n    }\n  }\n\n  // Check if user can access client\n  canAccessClient(clientId: string): boolean {\n    const user = get(currentUser);\n    if (!user) return false;\n\n    // Super admin can access all clients\n    if (user.role === 'super_admin') return true;\n\n    // Other roles can only access their assigned client\n    return user.client_id === clientId;\n  }\n}\n\n// Create and export auth service instance\nexport const authService = new AuthService();\n\n// Export auth state for direct access\nexport { authState };\n\n// Event listeners for token refresh and auth failure\nif (browser) {\n  // Handle token refresh events\n  window.addEventListener('token-refreshed', ((event: CustomEvent) => {\n    const tokenData = event.detail;\n    updateState({\n      accessToken: tokenData.access_token,\n      refreshToken: tokenData.refresh_token,\n    });\n    saveTokensToStorage(tokenData.access_token, tokenData.refresh_token);\n  }) as EventListener);\n\n  // Handle auth failure events\n  window.addEventListener('auth-failed', (() => {\n    authService.logout();\n  }) as EventListener);\n\n  // Initialize auth when store is imported\n  authService.initialize();\n} "],"names":["APIError","status","message","details","APIClient","accessToken","refreshToken","endpoint","options","response","url","headers","errorMessage","errorDetails","errorData","exp","now","fiveMinutes","tokenData","error","goto","credentials","request","sessionId","clientId","limit","offset","params","userId","apiClient","handleAPIError","initialState","authState","writable","isAuthenticated","derived","$state","currentUser","isLoading","authError","updateState","updates","state","setLoading","setError","TOKEN_STORAGE_KEY","saveTokensToStorage","loadTokensFromStorage","stored","timestamp","sevenDays","clearTokensFromStorage","AuthService","storedTokens","user","tokenResponse","get","permission","authService","event"],"mappings":"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"}